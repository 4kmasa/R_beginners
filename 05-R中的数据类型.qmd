---
title: "R中的数据类型和数据结构"
---

这部分内容是R语言基础中的基础，也是R语言的核心内容，是必须掌握的内容。但是这部分内容也是会让没有编程基础的人觉得难以理解的内容，需要静下心来认真学习。

## 数据类型

医学统计学中会把数据分为**计量资料、计数资料、等级资料**等不同的类型，R语言中也有类似的分类。

R中的数据类型主要有以下几类：

- 数值型（numeric）
- 整数型（integer）
- 字符型（character）
- 逻辑型（logical）
- 复数型（complex）
- 原生型（raw）

其中常见的是前4种，后两种少见，对于初学者不需要了解。

### 数值型

顾名思义，就是表示数字的一种方式，可以是整数或小数：

```{r}
# 把一个整数存储到变量中
my_integer <- 5

# 查看数据类型
typeof(my_integer)

# 把一个小数存储到变量中
my_float <- 3.14
my_float # 查看数据类型
```

虽然数字5没有小数点，但是它此时依然是`numeric`类型。

### 整数型

整数型也是表示数字的，没有小数点，但是需要在结尾添加`L`才行：

```{r}
integer_variable <- 186L
typeof((integer_variable))
```

### 字符型

是表示文本的一种方式，通常用引号括起来的都是字符型，双引号或者单引号都可以，但必须是英文状态下的引号：

```{r}
# 把一段文字存储到变量中
my_string <- "Hello, R!"
typeof(my_string)
```

### 逻辑型

又称为布尔型（boolean），用来表示是或否，只能是`TRUE`（是）或`FALSE`（否），而且不能加引号，加了引号就变成字符型了。

```{r}
# 把一个逻辑值存储到变量中
my_logical <- TRUE
typeof(my_logical)
```

## 数据集

数据集通常是由不同类型的数据构成的一个矩形数组，行表示观测，列表示变量，我们用的最多的数据集是**表格型**的结构，下表是一个医学中常见的病例数据集演示：

![](figs/PixPin_2024-05-07_19-58-03.png)

不同的行业对于数据集的行和列叫法不同。统计学家称它们为**观测**（observation）和**变量**（variable），数据库分析师则称其为**记录**（record）和**字段**（field），数据挖掘和机器学习学科的研究者则把它们叫作**示例**（example）和**属性**（attribute）。

在上标所示的数据集中，`PatientID`是行标识符（或者叫“行名”），`AdmDate`是日期型变量，`Age`是连续型变量，`Diabetes`是名义型变量，`Status`是有序型变量。

R中有许多用于存储数据的结构，包括标量、向量、数组、数据框和列表等。上表的结构实际上是R中的数据框（data.frame）。多样化的数据结构赋予了R极其灵活的数据处理能力。

在上表中，`PatientID`、`AdmDate`和`Age`为数值型（numeric）变量，而`Diabetes`和`Status`则为字符型（character）变量。R将实例标识符称为rowmames（行名），将类别型（包括名义型和有序型）变量称为因子（factors）。我们会在下一节中讲解这些内容。

## 数据结构

R拥有许多用于存储数据的对象类型，包括标量、向量、矩阵、数组、数据框和列表等。它们在存储数据的类型、创建方式、结构复杂度，以及用于定位和访问其中个别元素的标记等方面均有所不同。下图给出了这些数据结构的一个示意图。

![R中的数据结构](figs/PixPin_2024-02-22_15-35-50.png)

:::{.callout-note}
R中有一些术语较为独特，可能会对新用户造成困扰。在R中，**对象**（object）是指可以赋值给变量的任何事物，包括常量、数据结构、函数，甚至图形。对象都拥有某种模式，描述了此对象是如何存储的，以及某个类，像print这样的泛型函数表明如何处理此对象。
与其他标准统计软件（如SAS、SPSS和Stata）中的数据集类似，**数据框**（dataframe）是R中用于存储数据的一种结构：列表示变量，行表示观测。在同一个数据框中可以存储不同类型（如数值型、字符型）的变量。数据框将是你用来存储数据集的主要数据结构。
:::

### 向量

向量，vector，就是同一类型的多个数据，可以是数值型、整数型、字符型、逻辑型等，但是**只能是同一类型**。

在R中，使用函数`c()`创建向量：

```{r}
# 创建一个名字是a的向量
a <- c(1, 2, 5, 3, 6, -2, 4)
class(a) # 查看类型
# 创建一个名字是b的向量
b <- c("one", "two", "three")

# 创建一个名字是d的向量，不用c是为了避免和函数c()混淆
d <- c(TRUE, TRUE, TRUE, FALSE, TRUE, FALSE)
```

这里，`a`是数值型向量，`b`是字符型向量，而`d`是逻辑型向量。

注意，单个向量中的数据必须拥有相同的类型或模式（数值型、字符型或逻辑型）。同一向量中无法混杂不同类型的数据。

:::{.callout-tip}
标量是只含一个元素的向量，例如f <- 3、g <- "US"和h <- TRUE。它们用于保存常量。
:::

通过在*方括号*中给定元素所处位置的数值，我们可以访问向量中的元素。例如，a[c(2, 4)]
用于访问向量`a`中的第二个和第四个元素。更多示例如下：

```{r}
a <- c(1, 2, 5, 3, 6, -2, 4)

a[3] # 取第3个元素
a[c(1,3,5)] # 取第1，3，5个元素
a[c(1:3)] # 取第1到第3个元素
```

### 数据框

数据框，data.frame，可能是大家最常用的数据结构了。我们的excel数据读进来一般默认都是数据框结构。

数据框由不同的行和列构成，不同的列可以包含不同类型（数值型、字符型等）的数据，比如可以其中一列是数值型，另一列是逻辑型，另一列是字符型，等。但是同一列中必须是相同的类型。

数据框可通过函数`data.frame()`创建，使用方式如下：

```{r,eval=FALSE}
mydata <- data.frame(col1, col2, col3,...)
```

其中的列向量col1、col2、col3等可为任何类型（如字符型、数值型或逻辑型）。

以下代码会创建一个数据框，这个数据框有4列，第一列的名字是`patientID`，是数值型；第二列的名字是`age`，也是数值型；第三列的名字是`diabetes`，是字符型；第4列的名字是`status`，也是字符型：

```{r}
patientID <- c(1, 2, 3, 4)
age <- c(25, 34, 28, 52)
diabetes <- c("Type1", "Type2", "Type1", "Type1")
status <- c("Poor", "Improved", "Excellent", "Poor")

patientdata <- data.frame(patientID, age, diabetes, status)
patientdata
```

我们首先建立了4个向量，然后使用函数`data.frame()`将4个向量组合在一起，就变成了一个数据框data.frame，所以你也可以把数据框看成是多个向量的组合。

如果我们要选择其中的某些行或者某些列，或者某个元素（比如，第2行第3列的值），有多种不同的方法实现。

可以通过方括号实现。

数据框和向量不一样，向量是一维的，数据框既有行也有列，**数据框是二维的**，所以在使用方括号时，我们也要指定行和列，行和列之间用`,`隔开。

以下是常见方法，**必须要记住**：

```{r}
patientdata[1, 2] # 取第1行第2列的值 

patientdata[1:2,] # 取第1行到第2行，取所有列，省略数字就是取所有

patientdata[, 1:3] # 去所有行，第1列到第3列

patientdata[c(1,4), c(1,3)] # 取第1行和第4行，第1列和第3列
```

如果你在方括号中不写`,`，那么默认是选取其中的列和所有行：

```{r}
patientdata[c(1,3)] # 取第1列和第3列，所有的行
```

除了使用数字序号这种，也可以直接使用列名进行选取：

```{r}
patientdata[, c("patientID", "diabetes")]
```

除了使用方括号，还可以使用美元符号`$`选取列：

```{r}
# 选取patientID这一列
patientdata$patientID
```

如果你想生成`diabetes`和`病情变量`status`的列联表，可以使用`table()`函数：

```{r}
table(patientdata$diabetes, patientdata$status)
```

医学生应该都能看懂这个结果什么意思吧？

在每个变量名前都键入一次`patientdata$`的写法是不符合编程思想的，是很繁琐的，所以给大家介绍一个`with()`函数，在`with()`函数内部，你可以不同写数据集的名字：

```{r}
with(patientdata,
     table(diabetes, status)
     )
```

`patientdata`这个数据集有4列，每一列都有一个列名，我们可以通过列名很轻松的选取其中的列，但是这个数据集没有行名，我们可以给它添加行名，这个数据共有4行，所以我们要准备4个名字，然后使用`rownames()`添加行名：

```{r}
# 准备4个名字
rws <- c("第一行", "第二行", "第三行", "第四行")

# 添加行名：
rownames(patientdata) <- rws
patientdata
```

这样就可以通过行名选择你想要的行了，比如选择第1行和第3行，所有的列：

```{r}
patientdata[c("第一行", "第三行"), ]
```

### 矩阵

矩阵，matrix，表面看起来像一个数据框，有行和列，也是二维的，但是矩阵里面的所有元素都**必须是同一类型的**，比如必须都是数值型，或者必须都是字符型，或者必须都是逻辑型，等。

可通过函数`matrix()`创建矩阵。一般使用格式为：

```{r,eval=FALSE}
myymatrix <- matrix(vector, nrow = 多少行？, ncol = 多少列？,
                    byrow = 是不是按行进行填充？,
                    dimnames = list(行名, 列名))
```

其中`vector`是矩阵所需要的元素，`nrow`和`ncol`用以指定行和列的维数，`dimnames`包含了可选的、以字符型向量表示的行名和列名。选项`byrow`则表明矩阵应当按行填充（`byrow=TRUE`）
还是按列填充（`byrow=FALSE`），默认情况下按列填充。

以下代码创建了一个5行、4列的矩阵，用1~20这20个数字进行填充，并且定义了行的名字和列的名字，并且是按列进行填充：

```{r}
y <- matrix(1:20, nrow=5, ncol=4,
            dimnames = list(c("行1","行2","行3","行4","行5"),
                            c("列1","列2","列3","列4"))
            ) 
y
```

对矩阵取行和列的语法和数据框完全一样，使用方括号即可，这里就不重复了。

### 数组

数组，array，类似矩阵，但可以有更多的维度（行、列以外的方向），比如可以有3维甚至更多，这种结构可能是你无法想象的，但是幸好这个结构用的不多。

数组可通过`array`函数创建，形式如下：

```{r,eval=FALSE}
myarray <- array(vector, dimensions, dimnames)
```

其中`vector`包含了数组中的数据，`dimensions`是一个数值型向量，给出了各个维度下标的最大
值，而`dimnames`是可选的、各维度名称标签的列表。

以下代码创建一个三维数组（2*3*4）：

```{r}
dim1 <- c("A1", "A2")
dim2 <- c("B1", "B2", "B3")
dim3 <- c("C1", "C2", "C3", "C4")

z <- array(1:24, c(2, 3, 4), dimnames=list(dim1, dim2, dim3))
z
```

### 因子

多数变量可归为名义型、有序型或连续型变量。

**名义型变量**是没有顺序之分的类别变量。糖尿病类型`diabetes`（`Type1`、`Type2`）是名义型变量的一例。即使在数据中`Type1`编码为`1`而`Type2`编码为2`，这也并不意味着二者是有序的。

**有序型变量**表示一种顺序关系，而非数量关系。病情`status`（`poor`、`improved`、`excellent`）是有序型变量的一个示例。很明显病情为`poor`（较差）病人的状态不如`improved`（病情好转）的病人，但并不知道相差多少。

**连续型变量**可以呈现为某个范围内的任意值，并同时表示了顺序和数量。年龄`Age`就是一个连续型变量，它能够表示像14.5或22.8这样的值以及其间的其他任意值。

类别（名义型）变量和有序类别（有序型）变量在R中称为**因子**（factor）。因子在R中非常重要，因为它决定了数据的分析方式以及如何进行视觉呈现。

因子可以通过函数`factor()`创建。比如用以下代码即可创建一个名为`status`的因子型向量：

```{r}
status <- factor(c("Poor", "Improved", "Excellent", "Poor"))
status
```

此时的`status`是一个因子型变量，也就是没有顺序之分的**名义型变量**，虽然给出了`Levels`，但是并不能表示它们之间有高低顺序，只是代表不同的水平而已，默认的水平顺序是按照首字母排列的。

如果要更改水平，可以使用以下代码：

```{r}
levels(status) <- c("Poor", "Excellent", "Improved")
status
```

或者直接在`factor()`中指定：

```{r}
status <- factor(c("Poor", "Improved", "Excellent", "Poor"),
                 levels = c("Poor", "Excellent", "Improved")
                 )
status
```

对于不同的水平，你也可以修改它的显示标签：

```{r}
status <- factor(c("Poor", "Improved", "Excellent", "Poor"),
                 levels = c("Poor", "Excellent", "Improved"),
                 labels = c("第一水平", "第二水平", "第三水平")
                 )
status
```

如果想要把某个变量变成**有序型变量**，可以使用`ordered=TRUE`参数：

```{r}
status <- factor(c("Poor", "Improved", "Excellent", "Poor"),
                 ordered = T
                 )
status
```

可以看到此时结果中的`Levels`有了小于号，用来表示先后顺序。

:::{.callout-note}
名义型变量和有序型变量在进行统计分析时会使用完全不同的方法，比如在进行线性回归或者cox回归分析时，名义型变量的默认方法是哑变量编码，而有序型变量的编码方式是正交多项式编码。相关内容可参考：[分类变量进行回归分析时的编码方案](https://mp.weixin.qq.com/s/8j0e3-PpbvTqGDnkPWRFyA)
:::

### 列表

列表，list，是除了数据框之外第二重要的数据结构，甚至可以说是最重要的数据结构，但同时也是最复杂的一种结构。

列表是一个大型的存储结构，里面啥都能放。比如，可以包含不同类型的数据，也可以包含其他数据结构，如向量、矩阵或数据框等，列表中也可以包含列表。

可以使用函数list()创建列表，使用语法为：

```{r,eval=FALSE}
mylist <- list(object1, object2, ...)
```

其中的对象可以是目前为止讲到的任何结构。你还可以为列表中的对象命名：

```{r,eval=FALSE}
mylist <- list(name1=object1, name2=object2, ...)
```

以下是一个创建列表的示例，我们先创建了5个不同类型的对象，然后把这些对象全部放到1个列表中：

```{r}
g <- "My First List" # 字符串
h <- c(25, 26, 18, 39) # 数值型向量
j <- matrix(1:10, nrow=5) # 矩阵
k <- c("one", "two", "three") # 字符型向量
l <- list("apple",1,TRUE) # 列表

mylist <- list(title=g, ages=h, j, k, l)
mylist
```

可以看出列表的成分非常复杂，上面的列表`mylist`的长度为5，因为有5个元素：

```{r}
# 查看长度
length(mylist)
```

前两个元素是有名字的：`title`和`ages`，后三个元素没有名字，但是有序号，分别是`[[3]]`、`[[4]]`、`[[5]]`。

如果你要提取列表中的元素，可以直接使用序号或者名字：

```{r}
mylist[[2]] # 取第2个元素
mylist[["title"]] # 取第一个元素
```


## 判断类型


## 类型转换



























